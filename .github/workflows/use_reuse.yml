name: Using Reusable Workflow
on: 
  push:
    branches:
      - '*'
#  push:
#    paths-ignore:
#      - '.github/workflows/*'
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Cache dependencies # Si las dependencias ya existen y no han cambiado, el paso de Install dependencies no las reinstalará de nuevo, pero si hay algún cambio, el hash cambiará y se recrearán. Este step se ejecuta no sólo cuando le toca sino también al final del job.
        id: cache
        uses: actions/cache@v3
        with:
#          path: ~/.npm
          path:  node_modules
          key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
      - name: Install dependencies
        if: steps.cache.outputs.cache-hit != 'true'  #cache-hit es una salida que genera la acción actions/cache@v3 que es true si se ha utilizado la cache.
        run: npm ci       # Este comando es similar a npm install, sólo que para un entorno de CI/CD. Toma las versión especificadas en package-lock.json
      - name: Run lint
        run: npm run lint
      - name: Run tests
        id: run-tests
        run: npm test
      - name: Upload test report
        # Como queremos generar el test-report (se declara en vite.config.js) sólo si hay tests fallidos hay que añadir la siguiente condición.
        if: failure() && steps.run-tests.outcome == 'failure' # failure() devuelve true si hay algún fallo en algún step. Sin embargo, steps.run-tests.outcome sólo será 'failure' si hay fallo en los tests.
        uses: actions/upload-artifact@v3
        with:
          name: test-report
          path: test.json
  build:
    runs-on: ubuntu-latest
    needs: test
    outputs:
      salida: ${{ steps.publish.outputs.script-test }}
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Cache dependencies # Si las dependencias ya existen y no han cambiado, el paso de Install dependencies no las reinstalará de nuevo, pero si hay algún cambio, el hash cambiará y se recrearán. Este step se ejecuta no sólo cuando le toca sino también al final del job.
        id: cache
        uses: actions/cache@v3
        with:
#          path: ~/.npm
          path:  node_modules
          key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
      - name: Install dependencies
        if: steps.cache.outputs.cache-hit != 'true'  #cache-hit es una salida que genera la acción actions/cache@v3 que es true si se ha utilizado la cache.
        run: npm ci       # Este comando es similar a npm install, sólo que para un entorno de CI/CD. Toma las versión especificadas en package-lock.json
      - name: Build project
        run: |
          echo "BUILDING PROJECT ..." 
          npm run build && echo "PROJECT BUILT!"
      - name: Publish JS filename
        id: publish
        run: find dist/assets/*.js -type f -execdir echo 'script-test={}' >> $GITHUB_OUTPUT ';' #$GITHUB_OUTPUT es una variable de entorno que trae por defecto github que guarda el par clave-valor del output.
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: dist-files
          path: dist
  deploy:
    needs: build
    uses: ./.github/workflows/reusable.yml
  report:
    needs: deploy
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Output information
        run: |
          echo "Something went wrong"
          echo "${{ toJSON(github) }}"

